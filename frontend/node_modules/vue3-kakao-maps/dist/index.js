import { ref as f, defineComponent as O, provide as j, onMounted as D, watch as c, computed as E, openBlock as p, createElementBlock as h, normalizeStyle as F, Fragment as C, renderList as I, createBlock as K, unref as b, createCommentVNode as L, renderSlot as _, toRaw as S, inject as x, onBeforeUnmount as B, withCtx as Z } from "vue";
const y = f(!1), Q = (g, u) => {
  const s = document.createElement("script"), e = u != null && u.length > 0 ? `&libraries=${u.join(",")}` : "";
  s.id = "kakao-map-api-script", s.src = `//dapi.kakao.com/v2/maps/sdk.js?appkey=${g}&autoload=false${e}`, document.body.appendChild(s), s.onload = () => {
    kakao.maps.load(() => {
      y.value = !0;
    });
  };
}, T = /* @__PURE__ */ O({
  __name: "KakaoMap",
  props: {
    width: { default: "40rem" },
    height: { default: "30rem" },
    markerList: {},
    infoWindowList: {},
    markerCluster: {},
    lat: {},
    lng: {},
    level: { default: 3 },
    mapTypeId: {},
    draggable: { type: Boolean, default: !0 },
    scrollwheel: { type: Boolean, default: !0 },
    disableDoubleClick: { type: Boolean, default: !1 },
    disableDoubleClickZoom: { type: Boolean, default: !1 },
    projectionId: { default: "kakao.maps.ProjectionId.WCONG" },
    tileAnimation: { type: Boolean, default: !0 },
    keyboardShortcuts: { type: [Boolean, Object] }
  },
  emits: ["onLoadKakaoMap", "onLoadKakaoMapMarkerCluster"],
  setup(g, { emit: u }) {
    const s = g, e = u, a = f(null), k = f();
    j("mapRef", k);
    const r = () => {
      const t = {
        center: new kakao.maps.LatLng(s.lat, s.lng),
        ...s
      };
      a.value !== null && (k.value = new window.kakao.maps.Map(a.value, t), e("onLoadKakaoMap", k.value));
    }, m = f(), o = (t) => {
      var d, v;
      if (t.markers === void 0 && t.customOverlayProps === void 0)
        throw new Error("클러스터 할 입력값이 없습니다.");
      if (k.value !== null) {
        if (t.markers !== void 0) {
          const l = f([]);
          (d = t.markers) == null || d.forEach((i) => {
            var w;
            const M = new kakao.maps.Marker({
              position: new kakao.maps.LatLng(i.lat, i.lng),
              image: i.image ?? void 0,
              title: i.title ?? void 0,
              draggable: typeof i.draggable == "boolean" ? i.draggable : !1,
              clickable: typeof i.clickable == "boolean" ? i.clickable : !1,
              zIndex: typeof i.zIndex == "number" ? i.zIndex : 0,
              opacity: i.opacity ?? 1,
              altitude: i.altitude ?? 0,
              range: i.range ?? void 0
            });
            (w = l.value) == null || w.push(M);
          }), m.value = new kakao.maps.MarkerClusterer({
            map: S(k.value),
            ...t,
            markers: l.value
          });
        }
        if (t.customOverlayProps !== void 0) {
          const l = f([]);
          (v = t.customOverlayProps) == null || v.forEach((i) => {
            var w;
            const M = new kakao.maps.CustomOverlay({
              position: new kakao.maps.LatLng(i.lat, i.lng),
              content: i.content,
              xAnchor: i.xAnchor,
              yAnchor: i.yAnchor,
              zIndex: i.zIndex,
              clickable: i.clickable
            });
            (w = l.value) == null || w.push(M);
          }), m.value = new kakao.maps.MarkerClusterer({
            map: S(k.value),
            ...t,
            markers: l.value
          });
        }
        e("onLoadKakaoMapMarkerCluster", m.value);
      }
    };
    D(() => {
      y.value && (r(), s.markerCluster !== void 0 && o(s.markerCluster));
    }), c(
      () => y.value,
      (t) => {
        t && (r(), s.markerCluster !== void 0 && o(s.markerCluster));
      }
    );
    const n = E(() => ({
      width: isFinite(+s.width) ? s.width + "px" : s.width,
      height: isFinite(+s.height) ? s.height + "px" : s.height
    }));
    return c([() => s.lat, () => s.lng], ([t, d]) => {
      var v;
      (v = k.value) == null || v.panTo(new kakao.maps.LatLng(t, d));
    }), c(
      () => s.draggable,
      (t) => {
        var d, v;
        t === void 0 || t ? (d = k.value) == null || d.setDraggable(!0) : (v = k.value) == null || v.setDraggable(!1);
      }
    ), c(
      () => s.level,
      (t) => {
        var d, v;
        t === void 0 ? (d = k.value) == null || d.setLevel(3) : (v = k.value) == null || v.setLevel(t);
      }
    ), c(
      () => s.mapTypeId,
      (t) => {
        var d, v;
        t === void 0 ? (d = k.value) == null || d.setMapTypeId(3) : (v = k.value) == null || v.setMapTypeId(t);
      }
    ), c(
      () => s.scrollwheel,
      (t) => {
        var d, v;
        t === void 0 ? (d = k.value) == null || d.setZoomable(!0) : (v = k.value) == null || v.setZoomable(t);
      }
    ), c(
      () => s.projectionId,
      (t) => {
        var d, v;
        t === void 0 ? (d = k.value) == null || d.setProjectionId(kakao.maps.ProjectionId.WCONG) : (v = k.value) == null || v.setProjectionId(t);
      }
    ), c(
      () => s.keyboardShortcuts,
      (t) => {
        var d, v;
        t === void 0 ? (d = k.value) == null || d.setKeyboardShortcuts(!1) : typeof t == "boolean" && ((v = k.value) == null || v.setKeyboardShortcuts(t));
      }
    ), (t, d) => (p(), h("div", {
      ref_key: "kakaoMapRef",
      ref: a,
      style: F(n.value)
    }, [
      s.markerList && s.markerCluster === void 0 ? (p(!0), h(C, { key: 0 }, I(s.markerList, (v, l) => (p(), K(b($), {
        key: v.key === void 0 ? l : v.key,
        lat: v.lat,
        lng: v.lng,
        "info-window": v == null ? void 0 : v.infoWindow,
        draggable: v.draggable,
        image: v.image,
        order: v.order,
        "order-bottom-margin": v.orderBottomMargin
      }, null, 8, ["lat", "lng", "info-window", "draggable", "image", "order", "order-bottom-margin"]))), 128)) : L("", !0),
      s.infoWindowList && s.markerCluster === void 0 ? (p(!0), h(C, { key: 1 }, I(s.infoWindowList, (v, l) => (p(), K(b(P), {
        key: v.key === void 0 ? l : v.key,
        lat: v.lat,
        lng: v.lng,
        content: v.content,
        visible: v.visible
      }, null, 8, ["lat", "lng", "content", "visible"]))), 128)) : L("", !0),
      _(t.$slots, "default")
    ], 4));
  }
}), N = {
  imageSrc: "https://t1.daumcdn.net/mapjsapi/images/2x/marker.png",
  imageWidth: 29,
  imageHeight: 42,
  imageOption: {}
}, $ = /* @__PURE__ */ O({
  __name: "KakaoMapMarker",
  props: {
    lat: {},
    lng: {},
    infoWindow: {},
    visible: { type: Boolean },
    image: {},
    title: {},
    draggable: { type: Boolean },
    clickable: { type: Boolean },
    zIndex: {},
    opacity: {},
    altitude: {},
    range: {},
    order: {},
    orderBottomMargin: {}
  },
  emits: [
    "onLoadKakaoMapMarker",
    "onClickKakaoMapMarker",
    "dragEndKakaoMapMarker",
    "mouseOverKakaoMapMarker",
    "mouseOutKakaoMapMarker",
    "deleteKakaoMapMarker"
  ],
  setup(g, { emit: u }) {
    const s = u, e = g, a = f(), k = x("mapRef"), r = (l) => {
      if (l != null) {
        if (l.imageSrc === void 0)
          throw new Error("이미지 경로가 존재하지 않습니다.");
      } else
        l = N;
      const i = new Image();
      i.src = l.imageSrc;
      const M = new kakao.maps.MarkerImage(
        l.imageSrc,
        new kakao.maps.Size(l.imageWidth ?? i.width, l.imageHeight ?? i.height),
        l.imageOption
      );
      a.value !== void 0 && a.value.setImage(M);
    }, m = (l) => {
      if (e.lat === void 0 || e.lng === void 0)
        throw new Error("marker의 위치가 없습니다.");
      const i = new kakao.maps.LatLng(e.lat, e.lng);
      a.value = new kakao.maps.Marker({
        position: i,
        title: e.title,
        draggable: e.draggable,
        clickable: e.clickable,
        zIndex: e.zIndex,
        opacity: e.opacity,
        altitude: e.altitude,
        range: e.range
      }), r(e.image), s("onLoadKakaoMapMarker", a.value), a.value.setMap(l), o(a.value), t(a.value), d(a.value), n(l, a.value);
    }, o = (l) => {
      kakao.maps.event.addListener(l, "click", () => {
        s("onClickKakaoMapMarker");
      });
    }, n = (l, i) => {
      kakao.maps.event.addListener(i, "dragend", function(M) {
        s("dragEndKakaoMapMarker", i);
      });
    }, t = (l) => {
      kakao.maps.event.addListener(l, "mouseover", () => {
        s("mouseOverKakaoMapMarker");
      });
    }, d = (l) => {
      kakao.maps.event.addListener(l, "mouseout", () => {
        s("mouseOutKakaoMapMarker");
      });
    }, v = (l) => `<div style="position:relative; bottom:${e.orderBottomMargin}">
        ${l}
      </div>`;
    return B(() => {
      var l;
      s("deleteKakaoMapMarker", a), (l = a.value) == null || l.setMap(null);
    }), c(
      [() => y.value, () => k, () => k == null ? void 0 : k.value],
      ([l, i, M]) => {
        l && i !== void 0 && M !== void 0 && m(M);
      },
      { immediate: !0 }
    ), c([() => e.lat, () => e.lng], ([l, i]) => {
      var M;
      y.value && ((M = a.value) == null || M.setPosition(new kakao.maps.LatLng(l, i)));
    }), c([() => e.image], () => {
      r(e.image);
    }), c(
      () => e.title,
      (l) => {
        var i;
        l !== void 0 && ((i = a.value) == null || i.setTitle(l));
      }
    ), c(
      () => e.draggable,
      (l) => {
        var i;
        (i = a.value) == null || i.setDraggable(l !== void 0 && l);
      }
    ), c(
      () => e.clickable,
      (l) => {
        var i;
        (i = a.value) == null || i.setDraggable(l !== void 0 && l);
      }
    ), c(
      () => e.zIndex,
      (l) => {
        var i;
        l !== void 0 && isFinite(l) && ((i = a.value) == null || i.setZIndex(Number(l)));
      }
    ), c(
      () => e.opacity,
      (l) => {
        var i, M;
        l !== void 0 && isFinite(l) ? (i = a.value) == null || i.setOpacity(Number(l)) : (M = a.value) == null || M.setOpacity(1);
      }
    ), (l, i) => {
      var M, w, A;
      return p(), h("div", null, [
        l.$slots.infoWindow ? (p(), K(b(P), {
          key: 0,
          marker: a.value,
          lat: e.lat,
          lng: e.lng,
          visible: (M = e == null ? void 0 : e.infoWindow) == null ? void 0 : M.visible
        }, {
          default: Z(() => [
            _(l.$slots, "infoWindow")
          ]),
          _: 3
        }, 8, ["marker", "lat", "lng", "visible"])) : e.infoWindow ? (p(), K(b(P), {
          key: 1,
          marker: a.value,
          lat: e.lat,
          lng: e.lng,
          content: (w = e == null ? void 0 : e.infoWindow) == null ? void 0 : w.content,
          visible: (A = e == null ? void 0 : e.infoWindow) == null ? void 0 : A.visible
        }, null, 8, ["marker", "lat", "lng", "content", "visible"])) : L("", !0),
        e.order ? (p(), K(b(z), {
          key: 2,
          lat: e.lat,
          lng: e.lng,
          "y-anchor": 0,
          content: v(e.order)
        }, null, 8, ["lat", "lng", "content"])) : L("", !0)
      ]);
    };
  }
}), G = { key: 0 }, P = /* @__PURE__ */ O({
  __name: "KakaoMapInfoWindow",
  props: {
    lat: {},
    lng: {},
    marker: {},
    content: {},
    disableAutoPan: { type: Boolean },
    removable: { type: Boolean, default: !1 },
    zIndex: {},
    altitude: {},
    range: { default: 500 },
    visible: { type: Boolean, default: !0 }
  },
  emits: ["onLoadKakaoMapInfoWindow"],
  setup(g, { emit: u }) {
    const s = u, e = g, a = f(), k = f(), r = x("mapRef"), m = (o) => {
      var t, d;
      if (e.lat === void 0 || e.lng === void 0)
        throw new Error("infoWindow의 위치가 없습니다.");
      const n = new kakao.maps.LatLng(e.lat, e.lng);
      a.value = new kakao.maps.InfoWindow({
        position: n,
        content: k.value ?? e.content ?? "",
        removable: e.removable,
        disableAutoPan: e.disableAutoPan,
        zIndex: e.zIndex,
        altitude: e.altitude,
        range: e.range
      }), e.visible && (s("onLoadKakaoMapInfoWindow", a.value), e.marker !== void 0 ? (t = a == null ? void 0 : a.value) == null || t.open(o, e.marker) : (d = a == null ? void 0 : a.value) == null || d.open(o));
    };
    return B(() => {
      (a == null ? void 0 : a.value) !== null && a.value !== void 0 && a.value.close();
    }), c(
      [() => y.value, () => r == null ? void 0 : r.value, () => y, () => r],
      ([o, n]) => {
        e.visible && o && n !== void 0 && n !== null && m(n);
      },
      { immediate: !0 }
    ), c(
      () => e.marker,
      (o) => {
        var n, t, d;
        !e.visible || (r == null ? void 0 : r.value) === void 0 || (a.value != null && ((n = a.value) == null || n.close()), o !== void 0 ? (t = a == null ? void 0 : a.value) == null || t.open(r == null ? void 0 : r.value, o) : (d = a == null ? void 0 : a.value) == null || d.open(r == null ? void 0 : r.value));
      },
      {
        immediate: !0
      }
    ), c(
      [() => k == null ? void 0 : k.value, () => k],
      ([o, n]) => {
        var t;
        o !== void 0 && ((t = a.value) == null || t.setContent(o));
      },
      { deep: !0 }
    ), c([() => e.lat, () => e.lng], ([o, n]) => {
      var t;
      (t = a.value) == null || t.setPosition(new kakao.maps.LatLng(o, n));
    }), c(
      () => e.content,
      (o) => {
        var n;
        (n = a.value) == null || n.setContent(o ?? "");
      }
    ), c(
      () => e.zIndex,
      (o) => {
        var n;
        (n = a.value) == null || n.setZIndex(o ?? 0);
      }
    ), c(
      () => e.altitude,
      (o) => {
        var n;
        (n = a.value) == null || n.setAltitude(o ?? 0);
      }
    ), c(
      () => e.range,
      (o) => {
        var n;
        (n = a.value) == null || n.setRange(o ?? 500);
      }
    ), c(
      () => e.visible,
      (o) => {
        o ? y != null && y.value && (r == null ? void 0 : r.value) !== void 0 && (r == null ? void 0 : r.value) !== null && m(r.value) : (a == null ? void 0 : a.value) !== null && a.value !== void 0 && a.value.close();
      }
    ), (o, n) => e.content && e.content.length > 0 || o.$slots.default ? (p(), h("div", G, [
      o.$slots.default ? (p(), h("div", {
        key: 0,
        ref_key: "contentSlot",
        ref: k
      }, [
        _(o.$slots, "default")
      ], 512)) : L("", !0)
    ])) : L("", !0);
  }
}), H = { key: 0 }, z = /* @__PURE__ */ O({
  __name: "KakaoMapCustomOverlay",
  props: {
    lat: {},
    lng: {},
    content: {},
    xAnchor: { default: 0.5 },
    yAnchor: { default: 0.5 },
    zIndex: {},
    clickable: { type: Boolean, default: !1 },
    visible: { type: Boolean, default: !0 }
  },
  emits: ["onLoadKakaoMapCustomOverlay"],
  setup(g, { emit: u }) {
    const s = u, e = g, a = f(), k = f(), r = x("mapRef"), m = (o) => {
      if (e.lat === void 0 || e.lng === void 0)
        throw new Error("KakaoMapCustomOverlay의 위치가 없습니다.");
      const n = new kakao.maps.LatLng(e.lat, e.lng);
      a.value = new kakao.maps.CustomOverlay({
        position: n,
        content: k.value ?? e.content ?? "",
        xAnchor: e.xAnchor,
        yAnchor: e.yAnchor,
        zIndex: e.zIndex,
        clickable: e.clickable
      }), e.visible && (a.value.setMap(o), s("onLoadKakaoMapCustomOverlay", a.value));
    };
    return B(() => {
      var o;
      a.value !== null && ((o = a.value) == null || o.setMap(null));
    }), c(
      [() => y.value, () => r == null ? void 0 : r.value, () => y, () => r],
      ([o, n]) => {
        e.visible && o && n !== void 0 && n !== null && m(n);
      },
      { immediate: !0 }
    ), c([() => e.lat, () => e.lng], ([o, n]) => {
      var t;
      (t = a.value) == null || t.setPosition(new kakao.maps.LatLng(o, n));
    }), c(
      () => e.content,
      (o) => {
        var n;
        (n = a.value) == null || n.setContent(o ?? "");
      }
    ), c(
      () => e.zIndex,
      (o) => {
        var n;
        (n = a.value) == null || n.setZIndex(o ?? 0);
      }
    ), c(
      () => e.visible,
      (o) => {
        var n;
        o ? y != null && y.value && (r == null ? void 0 : r.value) !== void 0 && (r == null ? void 0 : r.value) !== null && m(r.value) : (a == null ? void 0 : a.value) !== null && a.value !== void 0 && ((n = a.value) == null || n.setMap(null));
      }
    ), (o, n) => e.content && e.content.length > 0 || o.$slots.default ? (p(), h("div", H, [
      o.$slots.default ? (p(), h("div", {
        key: 0,
        ref_key: "contentSlot",
        ref: k
      }, [
        _(o.$slots, "default")
      ], 512)) : L("", !0)
    ])) : L("", !0);
  }
}), W = /* @__PURE__ */ O({
  __name: "KakaoMapPolyline",
  props: {
    latLngList: {},
    endArrow: { type: Boolean },
    strokeWeight: { default: 3 },
    strokeColor: { default: "#F10000" },
    strokeOpacity: { default: 0.6 },
    strokeStyle: { default: "solid" },
    zIndex: {}
  },
  setup(g) {
    const u = g, s = x("mapRef");
    let e = null;
    const a = E(() => u.latLngList.map((r) => new kakao.maps.LatLng(r.lat, r.lng))), k = (r) => {
      e = new kakao.maps.Polyline({
        path: a.value,
        endArrow: u.endArrow,
        strokeWeight: u.strokeWeight,
        strokeColor: u.strokeColor,
        strokeOpacity: u.strokeOpacity,
        strokeStyle: u.strokeStyle,
        zIndex: u.zIndex
      }), e.setMap(r);
    };
    return c(
      [() => y.value, () => s == null ? void 0 : s.value, () => y, () => s],
      ([r, m]) => {
        r && m !== void 0 && m !== null && k(m);
      },
      { immediate: !0 }
    ), c(
      () => u.latLngList,
      () => {
        e == null || e.setPath(a.value);
      },
      { deep: !0 }
    ), c(
      () => u.endArrow,
      () => {
        e == null || e.setMap(null), s !== void 0 && k(s.value);
      }
    ), c(
      [() => u.strokeWeight, () => u.strokeColor, () => u.strokeOpacity, () => u.strokeStyle],
      ([r, m, o, n]) => {
        e == null || e.setOptions({
          strokeWeight: r,
          strokeColor: m,
          strokeOpacity: o,
          strokeStyle: n
        });
      }
    ), c(
      () => u.zIndex,
      (r) => {
        r !== void 0 && (e == null || e.setZIndex(r));
      }
    ), B(() => {
      e == null || e.setMap(null);
    }), (r, m) => (p(), h("div", null, [
      _(r.$slots, "default")
    ]));
  }
}), U = { key: 0 }, V = { key: 1 }, q = /* @__PURE__ */ O({
  __name: "KakaoMapMarkerPolyline",
  props: {
    markerList: {},
    endArrow: { type: Boolean },
    strokeWeight: {},
    strokeColor: {},
    strokeOpacity: {},
    strokeStyle: {},
    zIndex: {},
    showMarkerOrder: { type: Boolean }
  },
  setup(g) {
    const u = g, s = x("mapRef"), e = f([]), a = (o) => {
      e.value.push(o);
    }, k = (o) => {
      const n = e.value.indexOf(o);
      e.value.splice(n, 1);
    }, r = (o) => {
      const n = u.markerList, t = e.value.indexOf(o);
      n[t].lat = o.getPosition().getLat(), n[t].lng = o.getPosition().getLng();
    }, m = (o, n) => `<div style="position:relative; bottom:${n}">
        ${o}
      </div>`;
    return (o, n) => (p(), h(C, null, [
      u.markerList && b(s) !== null ? (p(), h("div", U, [
        (p(!0), h(C, null, I(u.markerList, (t, d) => (p(), K(b($), {
          id: d,
          key: t.key === void 0 ? d : t.key,
          map: b(s),
          lat: t.lat,
          lng: t.lng,
          draggable: t.draggable,
          image: t.image,
          onOnLoadKakaoMapMarker: a,
          onDragEndKakaoMapMarker: r,
          onDeleteKakaoMapMarker: k
        }, null, 8, ["id", "map", "lat", "lng", "draggable", "image"]))), 128)),
        (p(!0), h(C, null, I(u.markerList, (t, d) => (p(), h("div", { key: d }, [
          d !== u.markerList.length - 1 ? (p(), K(b(W), {
            key: 0,
            latLngList: [
              { lat: u.markerList[d].lat, lng: u.markerList[d].lng },
              { lat: u.markerList[d + 1].lat, lng: u.markerList[d + 1].lng }
            ],
            endArrow: u.endArrow,
            strokeWeight: u.strokeWeight,
            strokeColor: u.strokeColor,
            strokeOpacity: u.strokeOpacity,
            strokeStyle: u.strokeStyle,
            zIndex: u.zIndex
          }, null, 8, ["latLngList", "endArrow", "strokeWeight", "strokeColor", "strokeOpacity", "strokeStyle", "zIndex"])) : L("", !0)
        ]))), 128))
      ])) : L("", !0),
      u.markerList && u.showMarkerOrder ? (p(), h("div", V, [
        (p(!0), h(C, null, I(u.markerList, (t, d) => (p(), K(b(z), {
          key: d,
          lat: t.lat,
          lng: t.lng,
          "y-anchor": 0,
          content: m(t.order !== void 0 ? t.order : d, t.orderBottomMargin)
        }, null, 8, ["lat", "lng", "content"]))), 128))
      ])) : L("", !0),
      _(o.$slots, "default")
    ], 64));
  }
}), X = {
  install: (g) => {
    g.component("KakaoMap", T), g.component("KakaoMapMarker", $), g.component("KakaoMapCustomOverlay", z), g.component("KakaoMapInfoWindow", P), g.component("KakaoMapMarkerPolyline", q), g.component("KakaoMapPolyline", W);
  }
};
export {
  T as KakaoMap,
  z as KakaoMapCustomOverlay,
  P as KakaoMapInfoWindow,
  $ as KakaoMapMarker,
  q as KakaoMapMarkerPolyline,
  W as KakaoMapPolyline,
  X as Vue3KakaoMaps,
  y as isKakaoMapApiLoaded,
  Q as useKakao
};
